// gridbot.gridc

// Objective: maximise resources per turn
// Strategy:
//   consume resources
//   punch any enemies
//   look for best location to move to

int dirtable[4];

int dopunch(dir)
{
  if (ffi(@LOOK, dir) != @CELL_ROBOT)
    return 0;
  return ffi(@PUNCH, dir);
}

int dopull(dir)
{
  if (ffi(@LOOK, dir) != @CELL_RESOURCE)
    return 0;
  return ffi(@PULL, dir);
}

int domove(dir)
{
  if (ffi(@LOOK, dir) != @CELL_EMPTY)
    return 0;
  return ffi(@MOVE, dir);
}

int consume()
{
  if (dopull(@NORTH))
    return 1;
  if (dopull(@EAST))
    return 1;
  if (dopull(@SOUTH))
    return 1;
  if (dopull(@WEST))
    return 1;

  if (dopunch(@NORTH))
    return 1;
  if (dopunch(@EAST))
    return 1;
  if (dopunch(@SOUTH))
    return 1;
  if (dopunch(@WEST))
    return 1;
}

int act()
{
  if (consume())
    return 1;
  if (ffi(@SCAN, 1, -1) == @CELL_RESOURCE)
  {
    if (ffi(@SCAN, -1, -1) == @CELL_RESOURCE)
    {
      return domove(@NORTH);
    }
    return domove(@EAST);
  }
  if (ffi(@SCAN, -1, 1) == @CELL_RESOURCE)
  {
    if (ffi(@SCAN, 1, 1) == @CELL_RESOURCE)
    {
      return domove(@SOUTH);
    }
    return domove(@WEST);
  }
  domove(dirtable[rand(3)]);
}

int main()
{
  dirtable[0] = @NORTH;
  dirtable[1] = @EAST;
  dirtable[2] = @WEST;
  dirtable[3] = @SOUTH;

  while (1)
  {
    act();
  }
}
